ğŸ”¹ How to Recognize Big-O Quickly
1. Look at the loops

Single loop over n items â†’ usually O(n).

Nested loops (loop inside loop) â†’ usually O(nÂ²).

Triple nested loops â†’ O(nÂ³).

Loop that halves the input each time (like binary search) â†’ O(log n).

Loop over n + another independent loop over m â†’ O(n + m).

2. Look at the work per loop

If each iteration does constant work (add, compare, assign) â†’ O(1) per iteration.

If each iteration itself calls a loop of size k, total = O(n Ã— k).

If each iteration makes recursive calls, analyze the recurrence (e.g., mergesort = O(n log n)).

3. Common Data Structure Operations

Array access by index = O(1)

Array search (linear) = O(n)

Binary search (sorted array) = O(log n)

HashMap put/get = O(1) average, O(n) worst case

Tree operations (balanced BST) = O(log n)

4. Spotting from Patterns

Some classic patterns have â€œdefaultâ€ complexities:

Sliding Window = O(n)

Two Pointers = O(n)

Binary Search = O(log n)

DFS/BFS = O(V + E) (vertices + edges)

Sorting = O(n log n)

Dynamic Programming (1D) = O(n) or O(nÂ²)

DP (2D grid) = O(m Ã— n)

5. Simplify the Expression

Big-O drops constants and lower terms:

O(2n) â†’ O(n)

O(n + nÂ²) â†’ O(nÂ²)

O(n log n + n) â†’ O(n log n)